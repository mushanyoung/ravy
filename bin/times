#!/usr/bin/env bash

# Script to convert timestamps, datetime strings, or ULIDs to human-readable format
# Works on both macOS and Linux

set -euo pipefail

# Detect OS
if [[ "$(uname)" == "Darwin" ]]; then
    OS="macos"
else
    OS="linux"
fi

# Function to convert ULID to Unix timestamp (seconds)
ulid_to_timestamp() {
    local ulid="$1"
    
    # ULID is 26 characters, first 10 characters are timestamp (base32)
    local timestamp_part="${ulid:0:10}"
    
    # Normalize Crockford's Base32: I/L -> 1, O -> 0
    timestamp_part=$(echo "$timestamp_part" | tr 'IL' '1' | tr 'O' '0')
    
    # Base32 decoding (ULID uses Crockford's Base32)
    local base32_chars="0123456789ABCDEFGHJKMNPQRSTVWXYZ"
    local result=0
    
    for ((i=0; i<${#timestamp_part}; i++)); do
        local char="${timestamp_part:$i:1}"
        # Convert to uppercase for consistency
        char=$(echo "$char" | tr '[:lower:]' '[:upper:]')
        local value=$(echo "$base32_chars" | grep -o . | grep -n "^$char$" | cut -d: -f1)
        if [[ -z "$value" ]]; then
            return 1
        fi
        value=$((value - 1))
        result=$((result * 32 + value))
    done
    
    # ULID timestamp is in milliseconds, convert to seconds
    echo $((result / 1000))
}

# Function to format timestamp for output
format_timestamp() {
    local timestamp="$1"
    local timezone="$2"
    
    if [[ "$OS" == "macos" ]]; then
        if [[ "$timezone" == "UTC" ]]; then
            TZ=UTC date -r "$timestamp" "+%Y-%m-%d %H:%M:%S %Z"
        else
            date -r "$timestamp" "+%Y-%m-%d %H:%M:%S %Z"
        fi
    else
        if [[ "$timezone" == "UTC" ]]; then
            TZ=UTC date -d "@$timestamp" "+%Y-%m-%d %H:%M:%S %Z"
        else
            date -d "@$timestamp" "+%Y-%m-%d %H:%M:%S %Z"
        fi
    fi
}

# Function to parse datetime string
parse_datetime() {
    local datetime_str="$1"
    
    # Handle UTC timezone indicators
    if [[ "$datetime_str" =~ Z$ ]] || [[ "$datetime_str" =~ \+00:00$ ]] || [[ "$datetime_str" =~ \+0000$ ]]; then
        # Remove timezone indicator and parse as UTC
        local clean_str=$(echo "$datetime_str" | sed 's/[Z+].*$//')
        
        if [[ "$OS" == "macos" ]]; then
            # Parse as UTC by using -u flag
            local timestamp=$(date -j -u -f "%Y-%m-%d %H:%M:%S" "$clean_str" "+%s" 2>/dev/null || \
                             date -j -u -f "%Y-%m-%dT%H:%M:%S" "$clean_str" "+%s" 2>/dev/null || \
                             date -j -u -f "%Y-%m-%d" "$clean_str" "+%s" 2>/dev/null)
            echo "$timestamp"
        else
            # Parse as UTC
            TZ=UTC date -d "$clean_str UTC" "+%s" 2>/dev/null || return 1
        fi
        return
    fi
    
    if [[ "$OS" == "macos" ]]; then
        # macOS date -j can parse various formats
        # Try common formats
        local timestamp=$(date -j -f "%Y-%m-%d %H:%M:%S" "$datetime_str" "+%s" 2>/dev/null || \
                         date -j -f "%Y-%m-%dT%H:%M:%S" "$datetime_str" "+%s" 2>/dev/null || \
                         date -j -f "%Y-%m-%d %H:%M:%S%z" "$datetime_str" "+%s" 2>/dev/null || \
                         date -j -f "%Y-%m-%dT%H:%M:%S%z" "$datetime_str" "+%s" 2>/dev/null || \
                         date -j -f "%Y-%m-%d" "$datetime_str" "+%s" 2>/dev/null || \
                         date -j "$datetime_str" "+%s" 2>/dev/null)
        echo "$timestamp"
    else
        # Linux date -d can parse many formats
        date -d "$datetime_str" "+%s" 2>/dev/null || return 1
    fi
}

# Function to convert a single input to timestamp
convert_input() {
    local input="$1"
    local timestamp
    
    # Check if input is numeric (timestamp)
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        local len=${#input}
        
        if [[ $len -le 10 ]]; then
            # Seconds
            timestamp="$input"
        elif [[ $len -le 13 ]]; then
            # Milliseconds
            timestamp=$((input / 1000))
        elif [[ $len -le 19 ]]; then
            # Nanoseconds
            timestamp=$((input / 1000000000))
        else
            return 1
        fi
    # Check if input is incomplete ULID (starts with 01, 3-25 characters total)
    elif [[ "$input" =~ ^01[0-9A-Za-z]{1,24}$ ]]; then
        # Pad with trailing zeros to make it 26 characters
        local padded_ulid="$input"
        local current_len=${#padded_ulid}
        local padding_needed=$((26 - current_len))
        # Generate padding string of zeros
        local padding=""
        for ((i=0; i<padding_needed; i++)); do
            padding="${padding}0"
        done
        padded_ulid="${padded_ulid}${padding}"
        timestamp=$(ulid_to_timestamp "$padded_ulid" 2>/dev/null) || return 1
    # Check if input is complete ULID (26 characters, alphanumeric, case-insensitive)
    elif [[ "$input" =~ ^[0-9A-Za-z]{26}$ ]]; then
        timestamp=$(ulid_to_timestamp "$input" 2>/dev/null) || return 1
    # Otherwise, treat as datetime string
    else
        timestamp=$(parse_datetime "$input" 2>/dev/null) || return 1
    fi
    
    # Validate timestamp is reasonable (between 1970 and 2100)
    if [[ $timestamp -lt 0 ]] || [[ $timestamp -gt 4102444800 ]]; then
        return 1
    fi
    
    echo "$timestamp"
}

# Function to check if a value is in an array
contains() {
    local value="$1"
    shift
    if [[ $# -eq 0 ]]; then
        return 1
    fi
    local array=("$@")
    for item in "${array[@]}"; do
        if [[ "$item" == "$value" ]]; then
            return 0
        fi
    done
    return 1
}

# Function to extract and process all timestamps from a string
process_string() {
    local input="$1"
    local found_any=false
    local seen_matches=()
    
    # Build regex patterns for different timestamp types
    # Numeric timestamps: seconds (10), milliseconds (13), nanoseconds (19)
    local numeric_pattern='\b[0-9]{19}\b|\b[0-9]{13}\b|\b[0-9]{10}\b'
    
    # ULIDs: complete (26 chars) or incomplete starting with 01 (3-25 chars)
    local ulid_pattern='\b[0-9A-Za-z]{26}\b|\b01[0-9A-Za-z]{1,24}\b'
    
    # ISO 8601 datetime formats: YYYY-MM-DD with optional time
    # Format 1: YYYY-MM-DDTHH:MM:SS with optional fractional seconds and timezone (T part is optional)
    local iso8601_t_pattern='[0-9]{4}-[0-9]{2}-[0-9]{2}(T[0-9]{2}:[0-9]{2}:[0-9]{2}(\.?[0-9]+)?(Z|[+-][0-9]{2}:?[0-9]{2})?)?'
    # Format 2: YYYY-MM-DD HH:MM:SS (space-separated)
    local iso8601_space_pattern='[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]]+[0-9]{2}:[0-9]{2}:[0-9]{2}'
    
    # Combine all patterns
    local all_patterns="${numeric_pattern}|${ulid_pattern}|${iso8601_t_pattern}|${iso8601_space_pattern}"
    
    while IFS= read -r match; do
        if [[ -n "$match" ]]; then
            # Check if already seen
            local already_seen=false
            if [[ ${#seen_matches[@]} -gt 0 ]]; then
                if contains "$match" "${seen_matches[@]}"; then
                    already_seen=true
                fi
            fi
            
            if [[ "$already_seen" == "false" ]]; then
                # For datetime strings, also check if they contain already-seen timestamps
                local skip=false
                if [[ ${#seen_matches[@]} -gt 0 ]]; then
                    for seen in "${seen_matches[@]}"; do
                        if [[ "$match" =~ $seen ]]; then
                            skip=true
                            break
                        fi
                    done
                fi
                
                if [[ "$skip" == "false" ]]; then
                    local timestamp=$(convert_input "$match" 2>/dev/null)
                    if [[ -n "$timestamp" ]]; then
                        found_any=true
                        seen_matches+=("$match")
                        echo "Match: \"$match\""
                        echo "  Local: $(format_timestamp "$timestamp" "local")"
                        echo "  UTC:   $(format_timestamp "$timestamp" "UTC")"
                        echo ""
                    fi
                fi
            fi
        fi
    done < <(echo "$input" | grep -oE "$all_patterns" | awk '{print length($0), $0}' | sort -rn | cut -d' ' -f2- | awk '!seen[$0]++')
    
    if [[ "$found_any" == "false" ]]; then
        return 1
    fi
}

# Test function
test() {
    local tests_passed=0
    local tests_failed=0
    local test_name
    
    echo "Running tests..."
    echo ""
    
    # Test helper function
    run_test() {
        test_name="$1"
        local input="$2"
        local expected_count="${3:-1}"  # Default to expecting 1 match
        
        local output=""
        local match_count=0
        
        # Capture output, allowing process_string to fail
        set +e
        output=$(process_string "$input" 2>&1)
        local exit_code=$?
        set -e
        
        if [[ $exit_code -eq 0 ]] && [[ -n "$output" ]]; then
            match_count=$(echo "$output" | grep -c "Match:" 2>/dev/null || echo "0")
        fi
        
        if [[ "$match_count" -ge "$expected_count" ]] && [[ -n "$output" ]] && ! echo "$output" | grep -q "Error:"; then
            echo "✓ PASS: $test_name"
            ((tests_passed++)) || true
            return 0
        else
            echo "✗ FAIL: $test_name (expected at least $expected_count match(es), got $match_count)"
            echo "  Input: $input"
            if [[ -n "$output" ]]; then
                echo "  Output: $output"
            fi
            ((tests_failed++)) || true
            return 1
        fi
    }
    
    # Test numeric timestamps
    run_test "Numeric timestamp (seconds)" "1609459200" 1
    run_test "Numeric timestamp (milliseconds)" "1609459200000" 1
    run_test "Numeric timestamp (nanoseconds)" "1609459200000000000" 1
    
    # Test ULIDs
    run_test "Complete ULID" "01ARZ3NDEKTSV4RRFFQ69G5FAV" 1
    run_test "Incomplete ULID" "01ARZ3NDEK" 1
    run_test "Short incomplete ULID" "01ARZ3" 1
    
    # Test datetime strings
    run_test "ISO 8601 with T separator" "2021-01-01T00:00:00Z" 1
    run_test "ISO 8601 space-separated" "2021-01-01 00:00:00" 1
    run_test "ISO 8601 date only" "2021-01-01" 1
    
    # Test multiple timestamps
    run_test "Multiple numeric timestamps" "ts1: 1609459200 ts2: 1609459200000" 2
    run_test "Mixed timestamp types" "ts: 1609459200 ulid: 01ARZ3NDEK date: 2021-01-01 00:00:00" 3
    
    # Test edge cases
    run_test "Timestamp in text" "The timestamp is 1609459200 in the log" 1
    run_test "Multiple ULIDs" "id1: 01ARZ3NDEK id2: 01ARZ3NDEKTSV4RRFFQ69G5FAV" 2
    
    echo ""
    echo "=== Testing Core Functions ==="
    echo ""
    
    # Test convert_input function
    test_convert_input() {
        test_name="$1"
        local input="$2"
        local expected_ts="$3"
        
        set +e
        local result=$(convert_input "$input" 2>&1)
        local exit_code=$?
        set -e
        
        if [[ $exit_code -eq 0 ]] && [[ "$result" == "$expected_ts" ]]; then
            echo "✓ PASS: $test_name"
            ((tests_passed++)) || true
            return 0
        else
            echo "✗ FAIL: $test_name (expected timestamp: $expected_ts, got: $result)"
            ((tests_failed++)) || true
            return 1
        fi
    }
    
    # Test convert_input - numeric timestamps
    test_convert_input "convert_input: seconds timestamp" "1609459200" "1609459200"
    test_convert_input "convert_input: milliseconds timestamp" "1609459200000" "1609459200"
    test_convert_input "convert_input: nanoseconds timestamp" "1609459200000000000" "1609459200"
    
    # Test convert_input - ULIDs
    # Known ULID: 01ARZ3NDEKTSV4RRFFQ69G5FAV should convert to a specific timestamp
    # We'll test that it returns a valid timestamp (not empty and reasonable)
    test_ulid_conversion() {
        test_name="$1"
        local input="$2"
        
        set +e
        local result=$(convert_input "$input" 2>&1)
        local exit_code=$?
        set -e
        
        if [[ $exit_code -eq 0 ]] && [[ -n "$result" ]] && [[ "$result" =~ ^[0-9]+$ ]] && [[ "$result" -gt 0 ]] && [[ "$result" -lt 4102444800 ]]; then
            echo "✓ PASS: $test_name (timestamp: $result)"
            ((tests_passed++)) || true
            return 0
        else
            echo "✗ FAIL: $test_name (got: $result)"
            ((tests_failed++)) || true
            return 1
        fi
    }
    
    test_ulid_conversion "convert_input: complete ULID" "01ARZ3NDEKTSV4RRFFQ69G5FAV"
    test_ulid_conversion "convert_input: incomplete ULID" "01ARZ3NDEK"
    
    # Test parse_datetime function
    test_parse_datetime() {
        test_name="$1"
        local input="$2"
        local expected_ts="$3"
        
        set +e
        local result=$(parse_datetime "$input" 2>&1)
        local exit_code=$?
        set -e
        
        if [[ $exit_code -eq 0 ]] && [[ "$result" == "$expected_ts" ]]; then
            echo "✓ PASS: $test_name"
            ((tests_passed++)) || true
            return 0
        else
            echo "✗ FAIL: $test_name (expected: $expected_ts, got: $result)"
            ((tests_failed++)) || true
            return 1
        fi
    }
    
    # Test parse_datetime - various formats
    # Note: We'll use a known timestamp for testing
    # 2021-01-01 00:00:00 UTC = 1609459200
    # But parsing depends on timezone, so we'll test that it returns a valid timestamp
    test_datetime_parsing() {
        test_name="$1"
        local input="$2"
        
        set +e
        local result=$(parse_datetime "$input" 2>&1)
        local exit_code=$?
        set -e
        
        if [[ $exit_code -eq 0 ]] && [[ -n "$result" ]] && [[ "$result" =~ ^[0-9]+$ ]] && [[ "$result" -gt 0 ]] && [[ "$result" -lt 4102444800 ]]; then
            echo "✓ PASS: $test_name (timestamp: $result)"
            ((tests_passed++)) || true
            return 0
        else
            echo "✗ FAIL: $test_name (got: $result)"
            ((tests_failed++)) || true
            return 1
        fi
    }
    
    test_datetime_parsing "parse_datetime: ISO 8601 with T" "2021-01-01T00:00:00"
    test_datetime_parsing "parse_datetime: ISO 8601 with space" "2021-01-01 00:00:00"
    test_datetime_parsing "parse_datetime: ISO 8601 date only" "2021-01-01"
    test_datetime_parsing "parse_datetime: ISO 8601 with Z" "2021-01-01T00:00:00Z"
    
    # Test format_timestamp function
    test_format_timestamp() {
        test_name="$1"
        local timestamp="$2"
        local timezone="$3"
        
        set +e
        local result=$(format_timestamp "$timestamp" "$timezone" 2>&1)
        local exit_code=$?
        set -e
        
        # Check that output is a valid datetime string (contains year, month, day, time)
        if [[ $exit_code -eq 0 ]] && [[ -n "$result" ]] && [[ "$result" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]]+[0-9]{2}:[0-9]{2}:[0-9]{2} ]]; then
            echo "✓ PASS: $test_name (formatted: $result)"
            ((tests_passed++)) || true
            return 0
        else
            echo "✗ FAIL: $test_name (got: $result)"
            ((tests_failed++)) || true
            return 1
        fi
    }
    
    # Test format_timestamp - known timestamp
    test_format_timestamp "format_timestamp: local timezone" "1609459200" "local"
    test_format_timestamp "format_timestamp: UTC timezone" "1609459200" "UTC"
    
    # Test ulid_to_timestamp function directly
    test_ulid_to_timestamp() {
        test_name="$1"
        local ulid="$2"
        
        set +e
        local result=$(ulid_to_timestamp "$ulid" 2>&1)
        local exit_code=$?
        set -e
        
        if [[ $exit_code -eq 0 ]] && [[ -n "$result" ]] && [[ "$result" =~ ^[0-9]+$ ]] && [[ "$result" -gt 0 ]] && [[ "$result" -lt 4102444800 ]]; then
            echo "✓ PASS: $test_name (timestamp: $result)"
            ((tests_passed++)) || true
            return 0
        else
            echo "✗ FAIL: $test_name (got: $result)"
            ((tests_failed++)) || true
            return 1
        fi
    }
    
    test_ulid_to_timestamp "ulid_to_timestamp: complete ULID" "01ARZ3NDEKTSV4RRFFQ69G5FAV"
    # Test incomplete ULID by padding it first (ulid_to_timestamp requires 26 chars)
    local incomplete_ulid="01ARZ3NDEK"
    local current_len=${#incomplete_ulid}
    local padding_needed=$((26 - current_len))
    local padding=""
    for ((i=0; i<padding_needed; i++)); do
        padding="${padding}0"
    done
    local padded_ulid="${incomplete_ulid}${padding}"
    test_ulid_to_timestamp "ulid_to_timestamp: padded incomplete ULID" "$padded_ulid"
    
    # Summary
    echo ""
    echo "Test Summary:"
    echo "  Passed: $tests_passed"
    echo "  Failed: $tests_failed"
    echo "  Total:  $((tests_passed + tests_failed))"
    
    if [[ $tests_failed -eq 0 ]]; then
        echo ""
        echo "All tests passed! ✓"
        return 0
    else
        echo ""
        echo "Some tests failed. ✗"
        return 1
    fi
}

# Main function
main() {
    local input
    
    # Check if running tests
    if [[ $# -gt 0 ]] && [[ "$1" == "test" ]]; then
        test
        exit $?
    fi
    
    # Read input from stdin if no arguments provided, otherwise use first argument
    if [[ $# -eq 0 ]]; then
        # Check if stdin is a terminal (interactive) or a pipe/file
        if [[ -t 0 ]]; then
            echo "Usage: $0 <timestamp|datetime|ulid>"
            echo "   or: echo 'text with timestamps' | $0"
            echo "   or: $0 test                    # Run tests"
            echo ""
            echo "Examples:"
            echo "  $0 1609459200              # Unix timestamp (seconds)"
            echo "  $0 1609459200000           # Unix timestamp (milliseconds)"
            echo "  $0 1609459200000000000     # Unix timestamp (nanoseconds)"
            echo "  $0 '2021-01-01 00:00:00'   # Datetime string"
            echo "  $0 '01ARZ3NDEK'            # ULID prefix (padded with zeros)"
            echo "  echo 'ts: 1609459200' | $0  # Extract from stdin"
            echo "  $0 test                    # Run test suite"
            exit 1
        else
            # Read from stdin
            input=$(cat)
        fi
    else
        input="$1"
    fi
    
    # Always use multi-match mode - extract all timestamps from the string
    if ! process_string "$input"; then
        echo "Error: No valid timestamps found in input" >&2
        exit 1
    fi
}

main "$@"

